name: Deploy to Production

on:
  push:
    branches:
      - main
    tags:
      - 'v*'
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build:
    name: Build Docker Image
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix=prod-
            type=raw,value=prod-latest
            type=raw,value=latest

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    name: Deploy to Production Server
    needs: build
    runs-on: self-hosted

    steps:
      - name: Set up deployment directory
        run: |
          mkdir -p ~/abet-production
          mkdir -p ~/abet-production/backups
          cd ~/abet-production

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create environment file
        run: |
          cd ~/abet-production
          cat > .env << EOF
          IMAGE_TAG=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:prod-latest
          ENVIRONMENT_NAME=production
          DB_PASSWORD=${{ secrets.PROD_DB_PASSWORD }}
          PROD_DB_PASSWORD=${{ secrets.PROD_DB_PASSWORD }}
          DB_ROOT_PASSWORD=${{ secrets.PROD_DB_ROOT_PASSWORD }}
          EOF

      - name: Copy docker-compose file
        run: |
          cd ~/abet-production
          cp $GITHUB_WORKSPACE/docker-compose.prod.yml .
          
          # Copy database init scripts if they exist
          if [ -d "$GITHUB_WORKSPACE/database" ]; then
            cp -r $GITHUB_WORKSPACE/database .
          fi

      - name: Create database backup
        run: |
          cd ~/abet-production
          
          # Check if database container exists and is running
          if docker compose -f docker-compose.prod.yml ps | grep -q "abet-db-prod.*Up"; then
            echo "Creating database backup..."
            BACKUP_FILE="backups/abet_prod_$(date +%Y%m%d_%H%M%S).sql"
          
            docker compose -f docker-compose.prod.yml exec -T database \
              mysqldump -u root -p${{ secrets.PROD_DB_ROOT_PASSWORD }} \
              --single-transaction --routines --triggers \
              abet_prod > "$BACKUP_FILE" || echo "Backup failed, continuing anyway..."
          
            if [ -f "$BACKUP_FILE" ]; then
              echo "Backup created: $BACKUP_FILE"
              ls -lh "$BACKUP_FILE"
            fi
          
            # Keep only last 7 days of backups
            find backups/ -name "*.sql" -mtime +7 -delete || true
          else
            echo "Database container not running, skipping backup (first deployment?)"
          fi

      - name: Login to Container Registry
        run: |
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin

      - name: Pull latest image
        run: |
          cd ~/abet-production
          docker compose -f docker-compose.prod.yml pull app

      - name: Perform rolling update
        run: |
          cd ~/abet-production
          
          echo "Starting rolling update..."
          
          # Check if old containers exist
          if docker ps -a | grep -q "abet-prod"; then
            echo "Existing deployment found, performing rolling update..."
          
            # Start new container with temporary name
            docker run -d \
              --name abet-prod-new \
              --env-file .env \
              --network abet-production_abet-network \
              ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:prod-latest || {
                echo "Failed to start new container"
                exit 1
              }
          
            # Wait for new container to be healthy
            echo "Waiting for new container to be healthy..."
            for i in {1..30}; do
              if docker exec abet-prod-new wget --quiet --tries=1 --spider http://localhost:8080/actuator/health 2>/dev/null; then
                echo "New container is healthy!"
                break
              fi
              if [ $i -eq 30 ]; then
                echo "New container failed health check"
                docker logs abet-prod-new --tail=50
                docker stop abet-prod-new
                docker rm abet-prod-new
                exit 1
              fi
              echo "Health check attempt $i/30..."
              sleep 2
            done
          
            # Stop and remove old container
            echo "Stopping old container..."
            docker compose -f docker-compose.prod.yml stop app
            docker compose -f docker-compose.prod.yml rm -f app
          
            # Remove temporary container (compose will manage it)
            docker stop abet-prod-new
            docker rm abet-prod-new
          else
            echo "First deployment detected..."
          fi
          
          # Start with docker compose (will create fresh or use existing)
          docker compose -f docker-compose.prod.yml up -d

      - name: Wait for services to be ready
        run: |
          echo "Waiting for services to stabilize..."
          sleep 15

      - name: Check service health
        run: |
          cd ~/abet-production
          
          # Check if containers are running
          if ! docker compose -f docker-compose.prod.yml ps | grep -q "Up"; then
            echo "Containers failed to start"
            docker compose -f docker-compose.prod.yml ps
            docker compose -f docker-compose.prod.yml logs --tail=50
            exit 1
          fi
          
          # Wait for health check (up to 60 seconds)
          for i in {1..12}; do
            if curl -f http://localhost:8080/actuator/health 2>/dev/null; then
              echo "Production application is healthy!"
              docker compose -f docker-compose.prod.yml ps
              exit 0
            fi
            echo "Health check attempt $i/12..."
            sleep 5
          done
          
          echo "Health check failed after 60 seconds"
          docker compose -f docker-compose.prod.yml logs --tail=100 app
          exit 1

      - name: Show deployment info
        if: success()
        run: |
          cd ~/abet-production
          echo "=== Production Deployment Summary ==="
          echo "Environment: Production"
          echo "Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:prod-latest"
          echo "Access URL: http://localhost:8080"
          echo "Deployed at: $(date)"
          echo ""
          echo "=== Running Containers ==="
          docker compose -f docker-compose.prod.yml ps
          echo ""
          echo "=== Container Resource Usage ==="
          docker stats --no-stream --format "table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}"
          echo ""
          echo "=== Recent Application Logs ==="
          docker compose -f docker-compose.prod.yml logs --tail=20 app

      - name: Cleanup old images
        if: success()
        run: |
          echo "Cleaning up old Docker images..."
          docker image prune -f
          
          # Keep only last 3 production images
          docker images ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }} | \
            grep -E 'prod|latest' | \
            tail -n +4 | \
            awk '{print $3}' | \
            xargs -r docker rmi -f || true

      - name: Rollback on failure
        if: failure()
        run: |
          cd ~/abet-production
          echo "Production deployment failed!"
          echo "Current status:"
          docker compose -f docker-compose.prod.yml ps
          echo ""
          echo "Recent logs:"
          docker compose -f docker-compose.prod.yml logs --tail=100
          echo ""
          echo "To rollback manually:"
          echo "1. Check available backups: ls -lh ~/abet-production/backups/"
          echo "2. Stop services: cd ~/abet-production && docker compose -f docker-compose.prod.yml down"
          echo "3. Restore database: docker compose -f docker-compose.prod.yml exec -T database mysql -u root -p abet_prod < backups/[backup-file]"
          echo "4. Start services: docker compose -f docker-compose.prod.yml up -d"

  notify:
    name: Send Deployment Notification
    needs: deploy
    runs-on: self-hosted
    if: always()

    steps:
      - name: Deployment status
        run: |
          if [ "${{ needs.deploy.result }}" == "success" ]; then
            echo "Production deployment completed successfully!"
            echo "Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:prod-latest"
            echo "Timestamp: $(date)"
          else
            echo "Production deployment failed!"
            echo "Check the logs above for details."
            exit 1
          fi